<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <title>La Prairie Pluvieuse - VR</title>
    <meta
      name="description"
      content="Environnement VR immersif avec physique"
    />

    <!-- 1. IMPORT A-FRAME & LIBRARIES -->
    <!-- A-Frame Core -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>

    <!-- A-Frame Extras (Animation, Controls, etc.) -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.0.0/dist/aframe-extras.min.js"></script>

    <!-- Physics System (Ammo Driver) -->
    <!-- STABLE: Use n5ro canonical release to prevent initializing errors -->
    <script src="https://mixedreality.mozilla.org/ammo.js/builds/ammo.wasm.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@v4.0.1/dist/aframe-physics-system.min.js"></script>

    <!-- Teleport Controls -->
    <script src="https://rawgit.com/fernsroth/aframe-teleport-controls/master/dist/aframe-teleport-controls.min.js"></script>

    <!-- Custom User Scripts -->
    <script src="./assets/js/christmas-utils.js"></script>

    <script>
      // Configuration simple pour la pluie (sera lancée plus bas)
      AFRAME.registerComponent("rain-drop", {
        init: function () {
          this.reset();
        },
        tick: function () {
          this.el.object3D.position.y -= 0.1;
          if (this.el.object3D.position.y < 0) {
            this.reset();
          }
        },
        reset: function () {
          // Position aléatoire autour du joueur (zone 20x20)
          var x = (Math.random() - 0.5) * 20;
          var z = (Math.random() - 0.5) * 20;
          var y = 10 + Math.random() * 5;
          this.el.object3D.position.set(x, y, z);
        },
      });

      // FIX PHYSICS: Enable CCD to prevent tunneling
      AFRAME.registerComponent("fix-physics", {
        init: function () {
          this.el.addEventListener("body-loaded", (e) => {
            const body = e.detail.body;
            if (body) {
              body.setCcdMotionThreshold(1e-7);
              body.setCcdSweptSphereRadius(0.02);
            }
          });
        },
      });

      // SLEEPY: Force object to sleep until touched/grabbed
      // This prevents them from falling through the floor on load
      AFRAME.registerComponent("sleepy", {
        init: function () {
          this.el.addEventListener("body-loaded", (e) => {
            const body = e.detail.body;
            if (body) {
              // 2 = ISLAND_SLEEPING (Ammo.js)
              body.setActivationState(2);
            }
          });
        },
      });

      // AI WILDEBEEST
      AFRAME.registerComponent("wildebeest-ai", {
        init: function () {
            this.direction = new THREE.Vector3(0, 0, 1);
            this.speed = 0.02;
            this.turnTimer = 0;
        },
        tick: function () {
            // Move forward (Negative Z is forward in WebGL/A-Frame)
            this.el.object3D.translateZ(-this.speed);

            this.turnTimer++;
            
            // Random turn every now and then
            if (this.turnTimer > 200 + Math.random() * 500) {
                this.turn();
            }

            // Boundary Check (Local to parent Enclosure)
            // New 8x8m enclosure centered at (0,0,4) roughly
            // Bounds: X [-3.5, 3.5], Z [0.5, 7.5]
            var pos = this.el.object3D.position;
            if (pos.x < -3.5 || pos.x > 3.5 || pos.z < 0.5 || pos.z > 7.5) {
                // Too close to fence, turn around!
                this.el.object3D.rotation.y += Math.PI + (Math.random() - 0.5);
                // Clamp position
                pos.x = Math.max(-3.4, Math.min(3.4, pos.x));
                pos.z = Math.max(0.6, Math.min(7.4, pos.z));
                this.turnTimer = 0;
            }
        },
        turn: function() {
            this.el.object3D.rotation.y += (Math.random() - 0.5) * 2;
            this.turnTimer = 0;
        }
      });

      // CAT AI - Linear Patrol (Back and Forth)
      AFRAME.registerComponent("cat-ai", {
        init: function () {
            this.speed = 0.02; // Faster
            this.maxDist = 5;  // 5 meters range
            this.startPos = this.el.object3D.position.clone();
            // Start moving forward?
        },
        tick: function () {
            // Move forward (Positive Z seems to be forward for this specific model)
            this.el.object3D.translateZ(this.speed);
            
            // Check distance from start
            var dist = this.el.object3D.position.distanceTo(this.startPos);
            if (dist > this.maxDist) {
                // Turn 180 degrees
                this.el.object3D.rotation.y += Math.PI;
                // Reset/Clamp slightly to prevent getting stuck if logic overshoots
                // But simple rotation is enough, it will walk back
            }
        }
      });

        // --- Grab system: components `grabbable` and `grabber` ---
        // Grabbable: attach this component (and optionally class="grabbable") to any entity
        // Grabber: attach to a hand entity or camera to enable grabbing with trigger/grip or mouse
        (function(){
            AFRAME.registerComponent('grabbable', {
                schema: {},
                init: function() {
                    // Track which entity currently grabs this one (null if free)
                    this.grabbedBy = null;
                },
                isGrabbed: function() {
                    return !!this.grabbedBy;
                },
                grab: function(byEl) {
                    if (this.grabbedBy) return false; // already grabbed
                    this.grabbedBy = byEl;
                    this.el.classList.add('is-grabbed');
                    this.el.emit('grab-start', { by: byEl });
                    console.log('[grabbable] grabbed by', byEl && byEl.id ? byEl.id : byEl);
                    return true;
                },
                release: function() {
                    var prev = this.grabbedBy;
                    this.grabbedBy = null;
                    this.el.classList.remove('is-grabbed');
                    this.el.emit('grab-end', { by: prev });
                    console.log('[grabbable] released by', prev && prev.id ? prev.id : prev);
                }
            });

            // Highlightable: toggle emissive highlight on demand via events
            AFRAME.registerComponent('highlightable', {
                schema: { color: { type: 'color', default: '#00ffd0' }, intensity: { type: 'number', default: 0.6 } },
                init: function() {
                    this._originals = [];
                    this._highlighted = false;
                    this.onHighlightOn = this.onHighlightOn.bind(this);
                    this.onHighlightOff = this.onHighlightOff.bind(this);
                    this.el.addEventListener('highlight-on', this.onHighlightOn);
                    this.el.addEventListener('highlight-off', this.onHighlightOff);
                },
                remove: function() {
                    this.el.removeEventListener('highlight-on', this.onHighlightOn);
                    this.el.removeEventListener('highlight-off', this.onHighlightOff);
                    if (this._highlighted) this._restore();
                },
                onHighlightOn: function() { this._apply(); },
                onHighlightOff: function() { this._restore(); },
                _apply: function() {
                    if (this._highlighted) return;
                    var color = new THREE.Color(this.data.color);
                    this.el.object3D.traverse(function(node){
                        if (node.isMesh && node.material) {
                            // store original emissive & intensity
                            var mat = node.material;
                            this._originals.push({ node: node, emissive: mat.emissive ? mat.emissive.clone() : new THREE.Color(0x000000), emissiveIntensity: mat.emissiveIntensity || 0 });
                            if (mat.emissive) mat.emissive.copy(color); else mat.emissive = color.clone();
                            mat.emissiveIntensity = this.data.intensity;
                            mat.needsUpdate = true;
                        }
                    }.bind(this));
                    this._highlighted = true;
                },
                _restore: function() {
                    if (!this._highlighted) return;
                    this._originals.forEach(function(orig){
                        if (orig.node && orig.node.material) {
                            var mat = orig.node.material;
                            if (orig.emissive) mat.emissive.copy(orig.emissive);
                            mat.emissiveIntensity = orig.emissiveIntensity || 0;
                            mat.needsUpdate = true;
                        }
                    });
                    this._originals = [];
                    this._highlighted = false;
                }
            });

            // Thrown fallback: apply simple kinematic velocity when physics not available
            AFRAME.registerComponent('thrown', {
                schema: {
                    v: { type: 'vec3' },
                    life: { type: 'number', default: 1.5 }
                },
                init: function() {
                    this.age = 0;
                    this.velocity = new THREE.Vector3(this.data.v.x, this.data.v.y, this.data.v.z);
                },
                tick: function(time, delta) {
                    var dt = delta / 1000;
                    this.age += dt;
                    if (this.age > this.data.life) {
                        this.el.removeAttribute('thrown');
                        return;
                    }
                    // simple gravity
                    this.velocity.y -= 9.8 * dt;
                    var pos = this.el.object3D.position;
                    pos.x += this.velocity.x * dt;
                    pos.y += this.velocity.y * dt;
                    pos.z += this.velocity.z * dt;
                    this.el.object3D.position.copy(pos);
                    this.el.object3D.updateMatrixWorld(true);
                }
            });

            AFRAME.registerComponent('grabber', {
                schema: {},
                init: function() {
                    this.grabbedEl = null;
                    this.offsetMatrix = new THREE.Matrix4();
                    this.invHandMatrix = new THREE.Matrix4();
                    this.tempMatrix = new THREE.Matrix4();
                    this._grabbedOriginals = new WeakMap();
                    this._handHistory = [];
                    this._maxHistory = 6; 

                    this.onDown = this.onDown.bind(this);
                    this.onUp = this.onUp.bind(this);

                    this.el.addEventListener('triggerdown', this.onDown);
                    this.el.addEventListener('gripdown', this.onDown);
                    this.el.addEventListener('triggerup', this.onUp);
                    this.el.addEventListener('gripup', this.onUp);
                },

                remove: function() {
                    this.el.removeEventListener('triggerdown', this.onDown);
                    this.el.removeEventListener('gripdown', this.onDown);
                    this.el.removeEventListener('triggerup', this.onUp);
                    this.el.removeEventListener('gripup', this.onUp);
                },

                onDown: function(evt) {
                    if (this.grabbedEl) return;

                    // Check for direct intersection from event (best for VR)
                    if (evt && evt.detail && evt.detail.intersectedEl) {
                        this._tryGrabCandidate(evt.detail.intersectedEl);
                        return;
                    }

                    // Fallback to raycaster check
                    var rc = this.el.components.raycaster;
                    var intersections = rc && rc.intersections ? rc.intersections : [];
                    for (var i = 0; i < intersections.length; i++) {
                        var obj = intersections[i].object;
                        if (obj && obj.el) {
                            this._tryGrabCandidate(obj.el);
                            if (this.grabbedEl) return;
                        }
                    }
                },

                _sampleHand: function(now) {
                    try {
                        var p = new THREE.Vector3();
                        this.el.object3D.getWorldPosition(p);
                        this._handHistory.push({ p: p.clone(), t: now });
                        if (this._handHistory.length > this._maxHistory) this._handHistory.shift();
                    } catch(e) { }
                },

                _tryGrabCandidate: function(candidate) {
                    var el = candidate;
                    while (el && el.tagName && el.tagName.toLowerCase() !== 'a-scene') {
                        if (el.components && el.components.grabbable) break;
                        if (el.classList && el.classList.contains('grabbable')) break;
                        el = el.parentEl;
                    }
                    if (!el || el.tagName.toLowerCase() === 'a-scene') return;

                    if (el.components && el.components.grabbable) {
                        if (!el.components.grabbable.isGrabbed()) {
                            this._grab(el);
                        }
                    } else if (el.classList && el.classList.contains('grabbable')) {
                        el.setAttribute('grabbable', '');
                        if (!el.components.grabbable.isGrabbed()) this._grab(el);
                    }
                },

                _grab: function(targetEl) {
                    if (!targetEl) return;
                    if (targetEl.components && targetEl.components.grabbable) {
                        var ok = targetEl.components.grabbable.grab(this.el);
                        if (!ok) { return; }
                    } else {
                        targetEl.setAttribute('grabbable', '');
                        targetEl.components.grabbable.grab(this.el);
                    }

                    try {
                        if (targetEl.hasAttribute && targetEl.hasAttribute('ammo-body')) {
                            var orig = targetEl.getAttribute('ammo-body');
                            this._grabbedOriginals.set(targetEl, { 'ammo-body': orig });
                            targetEl.setAttribute('ammo-body', 'type: kinematic; mass: 0');
                        }
                    } catch(e) { }

                    try {
                        this.invHandMatrix.copy(this.el.object3D.matrixWorld).invert();
                        this.offsetMatrix.copy(this.invHandMatrix).multiply(targetEl.object3D.matrixWorld);
                    } catch(e) {
                        this.offsetMatrix.identity();
                    }

                    this.grabbedEl = targetEl;
                    this.grabbedEl.emit('grabbed', { by: this.el });
                },

                onUp: function(evt) {
                    if (!this.grabbedEl) return;

                    var now = performance.now() / 1000;
                    this._sampleHand(now);
                    
                    // Simple Throw Logic
                    var hist = this._handHistory;
                    var vx = 0, vy = 0, vz = 0;
                    if (hist.length >= 2) {
                        var first = hist[0];
                        var last = hist[hist.length - 1];
                        var dt = last.t - first.t;
                        if (dt <= 0) dt = 0.016;
                        vx = (last.p.x - first.p.x) / dt;
                        vy = (last.p.y - first.p.y) / dt;
                        vz = (last.p.z - first.p.z) / dt;
                    }
                    var throwFactor = 1.5;
                    var throwVel = new THREE.Vector3(vx * throwFactor, vy * throwFactor, vz * throwFactor);
                    var maxSpeed = 20; // Cap speed
                    if (throwVel.length() > maxSpeed) throwVel.setLength(maxSpeed);

                    var released = this.grabbedEl;
                    var worldMat = new THREE.Matrix4().copy(released.object3D.matrixWorld);

                    if (released.components && released.components.grabbable) released.components.grabbable.release();

                    // Restore physics (Dynamic)
                    released.setAttribute('ammo-body', 'type: dynamic; mass: 1');
                    this._grabbedOriginals.delete(released);

                    var sceneEl = this.el.sceneEl;
                    sceneEl.appendChild(released);

                    released.object3D.matrix.copy(worldMat);
                    var pos = new THREE.Vector3(), quat = new THREE.Quaternion(), scale = new THREE.Vector3();
                    released.object3D.matrix.decompose(pos, quat, scale);
                    released.object3D.position.copy(pos);
                    released.object3D.quaternion.copy(quat);
                    released.object3D.scale.copy(scale);
                    released.object3D.updateMatrixWorld(true);

                    released.emit('released', { by: this.el });
                    
                    // Apply Velocity after slight delay to ensure physics body is ready
                    setTimeout(function() {
                        if (released.body && window.Ammo) {
                            var btVec = new Ammo.btVector3(throwVel.x, throwVel.y, throwVel.z);
                            released.body.setLinearVelocity(btVec);
                            if(released.body.activate) released.body.activate();
                            Ammo.destroy(btVec);
                        }
                    }, 50);

                    this.grabbedEl = null;
                },

                tick: function(time, delta) {
                    var now = performance.now() / 1000;
                    this._sampleHand(now);

                    if (!this.grabbedEl) return;

                    this.tempMatrix.copy(this.el.object3D.matrixWorld).multiply(this.offsetMatrix);
                    var pos = new THREE.Vector3(), quat = new THREE.Quaternion(), scale = new THREE.Vector3();
                    this.tempMatrix.decompose(pos, quat, scale);

                    this.grabbedEl.object3D.position.copy(pos);
                    this.grabbedEl.object3D.quaternion.copy(quat);
                    // No scale sync to avoid issues
                    this.grabbedEl.object3D.updateMatrixWorld(true);
                }
            });
        })();




    </script>
  </head>
  <body>
    <!-- Config Scene avec Physique Ammo (DEBUG DISABLED) -->
    <a-scene
      physics="driver: ammo; debug: false; gravity: -9.8"
      renderer="antialias: false; colorManagement: true; sortObjects: true"
    >
      <!-- 2. ASSETS -->
      <a-assets>
        <!-- Texture Sol Réaliste (CDN Three.js) -->
        <img
          id="grassTexture"
          src="https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/terrain/grasslight-big.jpg"
        />

        <!-- Modèles 3D -->
        <a-asset-item
          id="grassModel"
          src="./assets/models/Grass.glb"
        ></a-asset-item>
        <a-asset-item
          id="barnModel"
          src="./assets/models/wooden_barn.glb"
        ></a-asset-item>
        <a-asset-item
          id="fenceModel"
          src="./assets/models/fence.glb"
        ></a-asset-item>
        <a-asset-item
          id="wildebeestModel"
          src="./assets/models/wildebeest.glb"
        ></a-asset-item>
        <a-asset-item
          id="treeModel"
          src="./assets/models/Tree.glb"
        ></a-asset-item>
        <a-asset-item
          id="bushModel"
          src="./assets/models/bush.glb"
        ></a-asset-item>
        <a-asset-item
          id="stickModel"
          src="./assets/models/Stick.glb"
        ></a-asset-item>
        <a-asset-item
          id="crateModel"
          src="./assets/models/Crate.glb"
        ></a-asset-item>
        <a-asset-item
          id="hatModel"
          src="./assets/models/hat.glb"
        ></a-asset-item>
        <a-asset-item
          id="sunModel"
          src="./assets/models/Sun.glb"
        ></a-asset-item>
        <a-asset-item
          id="chatModel"
          src="./assets/models/cat.glb"
        ></a-asset-item>
        <a-asset-item
          id="swingModel"
          src="./assets/models/balancoire.glb"
        ></a-asset-item>

        <!-- Mixins Physiques & Interactions -->
        <!-- Objet attrapable standard (Logic Only) -->
        <a-mixin
          id="grabbable"
          grabbable
          movement="type: grabbable; stickiness: stickable"
        >
        </a-mixin>

        <a-mixin
          id="grassMixin"
          gltf-model="#grassModel"
          scale="0.1 0.1 0.1"
        ></a-mixin>

        <a-mixin
          id="stickMixin"
          gltf-model="#stickModel"
          scale="1 1 1"
          mixin="grabbable"
        >
        </a-mixin>

        <a-mixin
          id="hatMixin"
          gltf-model="#hatModel"
          scale="1 1 1"
          mixin="grabbable"
        >
        </a-mixin>

        <a-mixin
          id="coal"
          material="color:black"
          geometry="primitive:sphere; segments-height:7; segments-width:13; radius:0.1"
          mixin="grabbable"
        >
        </a-mixin>
        <a-mixin
          id="branch"
          material="color:#5C4033"
          geometry="primitive:branch"
          scale="0.2 0.2 0.2"
          mixin="grabbable"
        >
        </a-mixin>

        <!-- Mixin Arbre (Décor) - Physics removed for stability -->
        <a-mixin
          id="treeMixin"
          gltf-model="#treeModel"
          scale="3 3 3"
        >
        </a-mixin>

        <!-- Mixin Bush (Petit buisson) - Physics removed for stability -->
        <a-mixin
          id="bushMixin"
          gltf-model="#bushModel"
          scale="0.02 0.02 0.02"
        >
        </a-mixin>
      </a-assets>

      <!-- 3. ENVIRONNEMENT -->
      <!-- Ciel Ensoleillé (Bleu pur) -->
      <a-sky color="#87CEEB"></a-sky>

      <!-- Soleil -->
      <a-entity
        gltf-model="#sunModel"
        position="-20 50 -30"
        scale="5 5 5"
      ></a-entity>

      <!-- Lumière -->
      <a-entity light="type: ambient; color: #FFF; intensity: 0.7"></a-entity>
      <a-entity
        light="type: directional; color: #FFF; intensity: 1; castShadow: false"
        position="-1 1 0.5"
      ></a-entity>

      <a-plane
        src="#grassTexture"
        rotation="-90 0 0"
        width="100"
        height="100"
        repeat="20 20"
        material="roughness: 1; metalness: 0"
      >
      </a-plane>

      <!-- SOLID PHYSICS FLOOR (Invisible Box) -->
      <!-- Positioned at Y=-25 with height 50 so top face is at Y=0 -->
      <a-box
        id="physicsFloor"
        position="0 -25 0"
        width="200"
        height="50"
        depth="200"
        visible="false"
        ammo-body="type: static"
        ammo-shape="type: box"
      ></a-box>

      <!-- 4. ÉLÉMENTS SCÉNIQUES -->
      <!-- Hangar -->
      <a-entity
        gltf-model="#barnModel"
        position="-10 0 -15"
        scale="2 2 2"
        ammo-body="type: static"
        ammo-shape="type: box; fit: manual; halfExtents: 5 4 5; offset: 0 4 0"
      >
      </a-entity>

      <!-- Balançoire (Devant la maison) -->
      <!-- Réduite de 15% addtionnelle (0.02 * 0.85 = 0.017) -->
      <a-entity
        gltf-model="#swingModel"
        position="-10 0 -5"
        rotation="0 180 0"
        scale="0.017 0.017 0.017"
        ammo-body="type: static"
        ammo-shape="type: box; fit: manual; halfExtents: 50 100 20; offset: 0 50 0"
      ></a-entity>

      <!-- Enclos (Fence) - Moyen & Moyen Loin -->
      <!-- Position further back (2 0 -16) -->
      <a-entity position="2 0 -16" id="enclosArea">
        <!-- Carré de 8x8m (2 panneaux par côté) -->
        
        <!-- Façade (Z=0) covers X[-4, 4] -->
        <a-entity gltf-model="#fenceModel" position="-2 0 0" scale="1 0.9 1" ammo-body="type: static" ammo-shape="type: box; fit: manual; halfExtents: 2 0.6 0.2"></a-entity>
        <a-entity gltf-model="#fenceModel" position="2 0 0" scale="1 0.9 1" ammo-body="type: static" ammo-shape="type: box; fit: manual; halfExtents: 2 0.6 0.2"></a-entity>
        
        <!-- Arrière (Z=8) -->
        <a-entity gltf-model="#fenceModel" position="-2 0 8" scale="1 0.9 1" rotation="0 180 0" ammo-body="type: static" ammo-shape="type: box; fit: manual; halfExtents: 2 0.6 0.2"></a-entity>
        <a-entity gltf-model="#fenceModel" position="2 0 8" scale="1 0.9 1" rotation="0 180 0" ammo-body="type: static" ammo-shape="type: box; fit: manual; halfExtents: 2 0.6 0.2"></a-entity>
        
        <!-- Gauche (X=-4) covers Z[0, 8] -->
        <a-entity gltf-model="#fenceModel" position="-4 0 2" scale="1 0.9 1" rotation="0 90 0" ammo-body="type: static" ammo-shape="type: box; fit: manual; halfExtents: 2 0.6 0.2"></a-entity>
        <a-entity gltf-model="#fenceModel" position="-4 0 6" scale="1 0.9 1" rotation="0 90 0" ammo-body="type: static" ammo-shape="type: box; fit: manual; halfExtents: 2 0.6 0.2"></a-entity>
        
        <!-- Droite (X=4) -->
        <a-entity gltf-model="#fenceModel" position="4 0 2" scale="1 0.9 1" rotation="0 90 0" ammo-body="type: static" ammo-shape="type: box; fit: manual; halfExtents: 2 0.6 0.2"></a-entity>
        <a-entity gltf-model="#fenceModel" position="4 0 6" scale="1 0.9 1" rotation="0 90 0" ammo-body="type: static" ammo-shape="type: box; fit: manual; halfExtents: 2 0.6 0.2"></a-entity>

        <!-- 2 Gnous (Wildebeests) - Inside pen -->
        <a-entity
          id="gnou1"
          gltf-model="#wildebeestModel"
          position="0 0 4"
          scale="0.7 0.7 0.7"
          animation-mixer="clip: *walk*; loop: repeat; timeScale: 1.0"
          wildebeest-ai
        ></a-entity>
        <a-entity
          id="gnou2"
          gltf-model="#wildebeestModel"
          position="2 0 5"
          scale="0.7 0.7 0.7"
          animation-mixer="clip: *walk*; loop: repeat; timeScale: 0.9"
          wildebeest-ai
        ></a-entity>
      </a-entity>

      <!-- Végétation & Loot -->
      <a-entity position="0 0 0" id="vegetation"></a-entity>

      <!-- LE CHAT -->
      <!-- Scale 0.05. Rehaussé Y=0.15 pour ne pas être enterré -->
      <!-- PATROL AI: Linear walk with turn -->
      <a-entity
        gltf-model="#chatModel"
        position="-12 0 -11"
        scale="0.0024 0.0024 0.0024"
        rotation="0 90 0"
        animation-mixer="clip: *; loop: repeat; timeScale: 2.0"
        cat-ai
      ></a-entity>

      <!-- 5. LA CAISSE SPÉCIALE INTERACTIVE -->
      <a-entity position="-6 0 -11">
        <!-- Caisse en bois -->
        <a-entity
          gltf-model="#crateModel"
          id="mainCrate"
          scale="1 1 1"
          ammo-body="type: static"
          ammo-shape="type: box; fit: manual; halfExtents: 0.5 0.5 0.5; offset: 0 0.5 0"
          movement="type: static; stickiness: sticky"
          position="0 0 0"
        >
        </a-entity>

      </a-entity>
      
      <!-- Invisible Safety Tabletop for Crate (Ensures loot lands) -->
      <a-box
        color="red"
        visible="false"
        position="-6 0.9 -11"
        width="1.2"
        height="0.2"
        depth="1.2"
        ammo-body="type: static"
        ammo-shape="type: box; fit: manual; halfExtents: 0.6 0.1 0.6"
      ></a-box>

      <!-- LOOT GLOBAL (Un-nested for physics stability) -->
      <!-- Crate World Pos: -6, 0, -11 -->
      
      <!-- Baton: Drop onto crate (Static Start) -->
      <a-entity
        mixin="stickMixin"
        position="-5.8 1.1 -10.9"
        rotation="90 0 45"
        ammo-shape="type: box; fit: manual; halfExtents: 0.05 0.05 0.5"
        ammo-body="type: static; mass: 0"
      ></a-entity>
      
      <!-- Coal: Drop onto crate (Static Start) -->
      <a-entity 
        mixin="coal" 
        position="-6.0 1.1 -11.0" 
        ammo-shape="type: sphere; fit: manual; halfExtents: 0.1 0.1 0.1"
        ammo-body="type: static; mass: 0"
      ></a-entity>

      <!-- CHAPEAU AU SOL (STATIC pour start, Dynamic on grab) -->
      <a-entity
          mixin="hatMixin"
          position="-5 0.5 -10"
          scale="0.2 0.2 0.2"
          ammo-shape="type: box; fit: manual; halfExtents: 0.3 0.3 0.3"
          ammo-body="type: static; mass: 0"
      ></a-entity>

      <!-- TEST CUBE (Bleu Static) -->
      <a-box 
        position="-4 1.5 -10" 
        color="blue" 
        depth="0.5" height="0.5" width="0.5"
        mixin="grabbable"
        ammo-shape="type: box; fit: manual; halfExtents: 0.25 0.25 0.25"
        ammo-body="type: static; mass: 0"
      ></a-box>

      <!-- 6. JOUEUR (RIG CAMERA) - RESTORED w/ GRABBER -->
        <!-- 6. JOUEUR (RIG CAMERA) - RESTORED w/ GRABBER & MOVEMENT -->
        <!-- Added movement-controls for joystick locomotion -->
        <a-entity id="rig" movement-controls="speed: 0.15; constrainToNavMesh: false">
            <a-camera id="camera" position="0 1.6 0" look-controls>
                <!-- Allow desktop cursor to hit UI only (clickable), preventing Grab interactions on PC -->
                <a-entity cursor="rayOrigin: mouse" raycaster="objects: .clickable"></a-entity>
            </a-camera>
            <a-entity id="lhand" hand-controls="hand: left" teleport-controls="cameraRig: #rig; teleportOrigin: #camera; button: trigger; collisionEntities: [ammo-shape]" visible="true" grabber raycaster="objects: .grabbable, .clickable; showLine: false"></a-entity>
            <a-entity id="rhand" hand-controls="hand: right" visible="true" grabber raycaster="objects: .grabbable, .clickable; showLine: false"></a-entity>
            <!-- Laser controls for pointer interaction with keys -->
            <a-entity laser-controls="hand: right" raycaster="objects: .clickable"></a-entity>
            <a-entity laser-controls="hand: left" raycaster="objects: .clickable"></a-entity>
        </a-entity>

    </a-scene>

    <!-- Script de génération procédurale & Animation -->
    <script>
      // Génération Pluie
      function createRain() {
        var scene = document.querySelector("a-scene");
        var rainCount = 200; 
        for (var i = 0; i < rainCount; i++) {
          var drop = document.createElement("a-entity");
          drop.setAttribute("geometry", "primitive: box; height: 0.1; width: 0.01; depth: 0.01");
          drop.setAttribute("material", "color: #AACCFF; opacity: 0.6; transparent: true");
          drop.setAttribute("rain-drop", "");
          scene.appendChild(drop);
        }
      }

      // Végétation
      function createVegetation() {
        var container = document.querySelector("#vegetation");

        // 1. ARBRES
        var treeCount = 32;
        var trees = [];

        for (var i = 0; i < treeCount; i++) {
          var valid = false, attempts = 0;
          var x, z;
          while (!valid && attempts < 50) {
            x = (Math.random() - 0.5) * 80;
            z = (Math.random() - 0.5) * 80;
            var dist = Math.sqrt((x - 0) ** 2 + (z - -10) ** 2);
            if (dist > 25) {
              valid = true;
              for (var t = 0; t < trees.length; t++) {
                if (Math.hypot(x - trees[t].x, z - trees[t].z) < 5) {
                  valid = false;
                  break;
                }
              }
            }
            attempts++;
          }

          if (valid) {
            trees.push({ x: x, z: z });
            var tree = document.createElement("a-entity");
            tree.setAttribute("mixin", "treeMixin");
            var s = (1.0 + Math.random() * 1.5) * 3;
            tree.setAttribute("position", { x: x, y: s * 1, z: z });
            tree.setAttribute("scale", { x: s, y: s, z: s });
            tree.setAttribute("rotation", { x: 0, y: Math.random() * 360, z: 0 });
            container.appendChild(tree);
          }
        }

        // 2. BUSHES
        var bushCount = 80;
        var isForbidden = function (x, z) {
          return x > -12 && x < 20 && z > -20 && z < -5;
        };

        for (var k = 0; k < bushCount; k++) {
          var x = (Math.random() - 0.5) * 70;
          var z = (Math.random() - 0.5) * 70;
          if (!isForbidden(x, z)) {
            var bush = document.createElement("a-entity");
            bush.setAttribute("mixin", "bushMixin");
            bush.setAttribute("position", { x: x, y: 0, z: z });
            var s = 0.5 + Math.random() * 0.5;
            bush.setAttribute("scale", { x: s, y: s, z: s });
            bush.setAttribute("rotation", { x: 0, y: Math.random() * 360, z: 0 });
            container.appendChild(bush);
          }
        }

        // 3. Herbe
        var grassCount = 150;
        for (var j = 0; j < grassCount; j++) {
          var angleG = Math.random() * Math.PI * 2;
          var radiusG = 2 + Math.random() * 45;
          var xG = Math.cos(angleG) * radiusG;
          var zG = Math.sin(angleG) * radiusG;
          
          var grass = document.createElement("a-entity");
          grass.setAttribute("mixin", "grassMixin");
          grass.setAttribute("position", { x: xG, y: 0, z: zG });
          grass.setAttribute("rotation", { x: 0, y: Math.random() * 360, z: 0 });
          container.appendChild(grass);
        }


      }

      window.addEventListener("load", function () {
        // DELAY START to allow Physics Engine (WASM) to fully initialize
        setTimeout(function() {
            createRain();
            createVegetation();
        }, 1000);
      });
    </script>
  </body>
</html>
