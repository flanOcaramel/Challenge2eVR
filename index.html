<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grande Plaine Verte avec Brouillard et Pluie</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Créer la scène
        const scene = new THREE.Scene();
        
        // Ajouter du brouillard plus proche
        scene.fog = new THREE.Fog(0x808080, 1, 80);
        
        // Caméra
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);


        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x808080); // Ciel gris
        document.body.appendChild(renderer.domElement);


        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Sol avec texture d'herbe
        const textureLoader = new THREE.TextureLoader();
        const grassTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/terrain/grasslight-big.jpg');
        grassTexture.wrapS = THREE.RepeatWrapping;
        grassTexture.wrapT = THREE.RepeatWrapping;
        grassTexture.repeat.set(20, 20);
        const planeGeometry = new THREE.PlaneGeometry(100, 100);
        const planeMaterial = new THREE.MeshLambertMaterial({ map: grassTexture });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2; // Allonger horizontalement
        scene.add(plane);

        // Fonction pour créer un arbre
        function createTree(x, z, type) {
            // Tronc
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 1, z);
            scene.add(trunk);

            // Feuillage
            let leavesGeometry;
            if (type === 'sphere') {
                leavesGeometry = new THREE.SphereGeometry(1);
            } else if (type === 'cone') {
                leavesGeometry = new THREE.ConeGeometry(1, 2, 8);
            }
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(x, 2.5, z);
            scene.add(leaves);
        }


        // Ajouter une vingtaine d'arbres
        for (let i = 0; i < 20; i++) {
            const x = (Math.random() - 0.5) * 80;
            const z = (Math.random() - 0.5) * 80;
            const type = Math.random() > 0.5 ? 'sphere' : 'cone';
            createTree(x, z, type);
        }
        
        // Lumière
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 10, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Joueur
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(0, 0.5, 0);
        scene.add(player);

        // Contrôles du joueur
        const keys = {};
        window.addEventListener('keydown', (event) => {
            keys[event.code] = true;
        });
        window.addEventListener('keyup', (event) => {
            keys[event.code] = false;
        });
        
        // Particules de pluie
        const rainCount = 1000;
        const rainGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(rainCount * 3);
        const velocities = [];
        
        for (let i = 0; i < rainCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 100; // x
            positions[i * 3 + 1] = Math.random() * 50 + 10; // y
            positions[i * 3 + 2] = (Math.random() - 0.5) * 100; // z
            velocities.push({ x: 0, y: -0.2, z: 0 });
        }
        
        rainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const rainMaterial = new THREE.PointsMaterial({ color: 0xADD8E6, size: 0.15, transparent: true, opacity: 0.8 }); // Bleu clair
        const rain = new THREE.Points(rainGeometry, rainMaterial);
        scene.add(rain);

        // Particules d'éclaboussures
        const splashCount = 500;
        const splashGeometry = new THREE.BufferGeometry();
        const splashPositions = new Float32Array(splashCount * 3);
        const splashVelocities = [];
        const splashLife = [];

        for (let i = 0; i < splashCount; i++) {
            splashPositions[i * 3] = 0;
            splashPositions[i * 3 + 1] = -1; // en dessous du sol
            splashPositions[i * 3 + 2] = 0;
            splashVelocities.push({ x: 0, y: 0, z: 0 });
            splashLife.push(0);
        }

        splashGeometry.setAttribute('position', new THREE.BufferAttribute(splashPositions, 3));
        const splashMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.6 });
        const splash = new THREE.Points(splashGeometry, splashMaterial);
        scene.add(splash);
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);

            // Mettre à jour les contrôles
            controls.update();

            // Mouvement du joueur
            const speed = 0.1;
            if (keys['KeyW'] || keys['ArrowUp']) {
                player.position.z -= speed;
            }
            if (keys['KeyS'] || keys['ArrowDown']) {
                player.position.z += speed;
            }
            if (keys['KeyA'] || keys['ArrowLeft']) {
                player.position.x -= speed;
            }
            if (keys['KeyD'] || keys['ArrowRight']) {
                player.position.x += speed;
            }

            // Animer la pluie
            const posArray = rainGeometry.attributes.position.array;
            for (let i = 0; i < rainCount; i++) {
                posArray[i * 3 + 1] += velocities[i].y;
                if (posArray[i * 3 + 1] < 0) {
                    posArray[i * 3 + 1] = 50;
                    // Créer éclaboussure
                    for (let j = 0; j < splashCount; j++) {
                        if (splashLife[j] <= 0) {
                            splashPositions[j * 3] = posArray[i * 3];
                            splashPositions[j * 3 + 1] = 0.1;
                            splashPositions[j * 3 + 2] = posArray[i * 3 + 2];
                            splashVelocities[j] = {
                                x: (Math.random() - 0.5) * 0.1,
                                y: Math.random() * 0.1 + 0.05,
                                z: (Math.random() - 0.5) * 0.1
                            };
                            splashLife[j] = 30; // durée de vie
                            break;
                        }
                    }
                }
            }
            rainGeometry.attributes.position.needsUpdate = true;

            // Animer les éclaboussures
            const splashPosArray = splashGeometry.attributes.position.array;
            for (let i = 0; i < splashCount; i++) {
                if (splashLife[i] > 0) {
                    splashPosArray[i * 3] += splashVelocities[i].x;
                    splashPosArray[i * 3 + 1] += splashVelocities[i].y;
                    splashPosArray[i * 3 + 2] += splashVelocities[i].z;
                    splashVelocities[i].y -= 0.005; // gravité
                    splashLife[i]--;
                    if (splashLife[i] <= 0) {
                        splashPosArray[i * 3 + 1] = -1;
                    }
                }
            }
            splashGeometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        
        animate();
        
        // Redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>